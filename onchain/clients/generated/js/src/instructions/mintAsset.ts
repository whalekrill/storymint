/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/web3.js';
import { LOCKED_SOL_PNFT_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';
import {
  getMintAssetArgsDecoder,
  getMintAssetArgsEncoder,
  type MintAssetArgs,
  type MintAssetArgsArgs,
} from '../types';

export const MINT_ASSET_DISCRIMINATOR = new Uint8Array([
  84, 175, 211, 156, 56, 250, 104, 118,
]);

export function getMintAssetDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MINT_ASSET_DISCRIMINATOR);
}

export type MintAssetInstruction<
  TProgram extends string = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountVault extends string | IAccountMeta<string> = string,
  TAccountAsset extends string | IAccountMeta<string> = string,
  TAccountMasterState extends string | IAccountMeta<string> = string,
  TAccountCollection extends string | IAccountMeta<string> = string,
  TAccountAuthority extends string | IAccountMeta<string> = string,
  TAccountOwner extends string | IAccountMeta<string> = string,
  TAccountUpdateAuthority extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountLogWrapper extends string | IAccountMeta<string> = string,
  TAccountMplCore extends
    | string
    | IAccountMeta<string> = 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountAsset extends string
        ? WritableSignerAccount<TAccountAsset> &
            IAccountSignerMeta<TAccountAsset>
        : TAccountAsset,
      TAccountMasterState extends string
        ? WritableAccount<TAccountMasterState>
        : TAccountMasterState,
      TAccountCollection extends string
        ? WritableAccount<TAccountCollection>
        : TAccountCollection,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            IAccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountUpdateAuthority extends string
        ? ReadonlyAccount<TAccountUpdateAuthority>
        : TAccountUpdateAuthority,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountLogWrapper extends string
        ? ReadonlyAccount<TAccountLogWrapper>
        : TAccountLogWrapper,
      TAccountMplCore extends string
        ? ReadonlyAccount<TAccountMplCore>
        : TAccountMplCore,
      ...TRemainingAccounts,
    ]
  >;

export type MintAssetInstructionData = {
  discriminator: ReadonlyUint8Array;
  args: MintAssetArgs;
};

export type MintAssetInstructionDataArgs = { args: MintAssetArgsArgs };

export function getMintAssetInstructionDataEncoder(): Encoder<MintAssetInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['args', getMintAssetArgsEncoder()],
    ]),
    (value) => ({ ...value, discriminator: MINT_ASSET_DISCRIMINATOR })
  );
}

export function getMintAssetInstructionDataDecoder(): Decoder<MintAssetInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['args', getMintAssetArgsDecoder()],
  ]);
}

export function getMintAssetInstructionDataCodec(): Codec<
  MintAssetInstructionDataArgs,
  MintAssetInstructionData
> {
  return combineCodec(
    getMintAssetInstructionDataEncoder(),
    getMintAssetInstructionDataDecoder()
  );
}

export type MintAssetAsyncInput<
  TAccountPayer extends string = string,
  TAccountVault extends string = string,
  TAccountAsset extends string = string,
  TAccountMasterState extends string = string,
  TAccountCollection extends string = string,
  TAccountAuthority extends string = string,
  TAccountOwner extends string = string,
  TAccountUpdateAuthority extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountLogWrapper extends string = string,
  TAccountMplCore extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  vault?: Address<TAccountVault>;
  /** The new asset being created */
  asset: TransactionSigner<TAccountAsset>;
  masterState?: Address<TAccountMasterState>;
  /** The collection this asset belongs to */
  collection: Address<TAccountCollection>;
  /** The authority signing for creation (optional) */
  authority?: TransactionSigner<TAccountAuthority>;
  /** The owner of the new asset */
  owner?: Address<TAccountOwner>;
  /** The authority on the new asset */
  updateAuthority?: Address<TAccountUpdateAuthority>;
  systemProgram?: Address<TAccountSystemProgram>;
  logWrapper?: Address<TAccountLogWrapper>;
  mplCore?: Address<TAccountMplCore>;
  args: MintAssetInstructionDataArgs['args'];
};

export async function getMintAssetInstructionAsync<
  TAccountPayer extends string,
  TAccountVault extends string,
  TAccountAsset extends string,
  TAccountMasterState extends string,
  TAccountCollection extends string,
  TAccountAuthority extends string,
  TAccountOwner extends string,
  TAccountUpdateAuthority extends string,
  TAccountSystemProgram extends string,
  TAccountLogWrapper extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
>(
  input: MintAssetAsyncInput<
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountAuthority,
    TAccountOwner,
    TAccountUpdateAuthority,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountAuthority,
    TAccountOwner,
    TAccountUpdateAuthority,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? LOCKED_SOL_PNFT_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    asset: { value: input.asset ?? null, isWritable: true },
    masterState: { value: input.masterState ?? null, isWritable: true },
    collection: { value: input.collection ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.vault.value) {
    accounts.vault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([118, 97, 117, 108, 116])),
        getAddressEncoder().encode(expectAddress(accounts.asset.value)),
      ],
    });
  }
  if (!accounts.masterState.value) {
    accounts.masterState.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([109, 97, 115, 116, 101, 114])),
        getAddressEncoder().encode(expectAddress(accounts.collection.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.asset),
      getAccountMeta(accounts.masterState),
      getAccountMeta(accounts.collection),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.logWrapper),
      getAccountMeta(accounts.mplCore),
    ],
    programAddress,
    data: getMintAssetInstructionDataEncoder().encode(
      args as MintAssetInstructionDataArgs
    ),
  } as MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountAuthority,
    TAccountOwner,
    TAccountUpdateAuthority,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >;

  return instruction;
}

export type MintAssetInput<
  TAccountPayer extends string = string,
  TAccountVault extends string = string,
  TAccountAsset extends string = string,
  TAccountMasterState extends string = string,
  TAccountCollection extends string = string,
  TAccountAuthority extends string = string,
  TAccountOwner extends string = string,
  TAccountUpdateAuthority extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountLogWrapper extends string = string,
  TAccountMplCore extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  vault: Address<TAccountVault>;
  /** The new asset being created */
  asset: TransactionSigner<TAccountAsset>;
  masterState: Address<TAccountMasterState>;
  /** The collection this asset belongs to */
  collection: Address<TAccountCollection>;
  /** The authority signing for creation (optional) */
  authority?: TransactionSigner<TAccountAuthority>;
  /** The owner of the new asset */
  owner?: Address<TAccountOwner>;
  /** The authority on the new asset */
  updateAuthority?: Address<TAccountUpdateAuthority>;
  systemProgram?: Address<TAccountSystemProgram>;
  logWrapper?: Address<TAccountLogWrapper>;
  mplCore?: Address<TAccountMplCore>;
  args: MintAssetInstructionDataArgs['args'];
};

export function getMintAssetInstruction<
  TAccountPayer extends string,
  TAccountVault extends string,
  TAccountAsset extends string,
  TAccountMasterState extends string,
  TAccountCollection extends string,
  TAccountAuthority extends string,
  TAccountOwner extends string,
  TAccountUpdateAuthority extends string,
  TAccountSystemProgram extends string,
  TAccountLogWrapper extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
>(
  input: MintAssetInput<
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountAuthority,
    TAccountOwner,
    TAccountUpdateAuthority,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): MintAssetInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountVault,
  TAccountAsset,
  TAccountMasterState,
  TAccountCollection,
  TAccountAuthority,
  TAccountOwner,
  TAccountUpdateAuthority,
  TAccountSystemProgram,
  TAccountLogWrapper,
  TAccountMplCore
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? LOCKED_SOL_PNFT_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    asset: { value: input.asset ?? null, isWritable: true },
    masterState: { value: input.masterState ?? null, isWritable: true },
    collection: { value: input.collection ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.asset),
      getAccountMeta(accounts.masterState),
      getAccountMeta(accounts.collection),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.logWrapper),
      getAccountMeta(accounts.mplCore),
    ],
    programAddress,
    data: getMintAssetInstructionDataEncoder().encode(
      args as MintAssetInstructionDataArgs
    ),
  } as MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountAuthority,
    TAccountOwner,
    TAccountUpdateAuthority,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >;

  return instruction;
}

export type ParsedMintAssetInstruction<
  TProgram extends string = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    payer: TAccountMetas[0];
    vault: TAccountMetas[1];
    /** The new asset being created */
    asset: TAccountMetas[2];
    masterState: TAccountMetas[3];
    /** The collection this asset belongs to */
    collection: TAccountMetas[4];
    /** The authority signing for creation (optional) */
    authority?: TAccountMetas[5] | undefined;
    /** The owner of the new asset */
    owner?: TAccountMetas[6] | undefined;
    /** The authority on the new asset */
    updateAuthority?: TAccountMetas[7] | undefined;
    systemProgram: TAccountMetas[8];
    logWrapper?: TAccountMetas[9] | undefined;
    mplCore: TAccountMetas[10];
  };
  data: MintAssetInstructionData;
};

export function parseMintAssetInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedMintAssetInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === LOCKED_SOL_PNFT_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      vault: getNextAccount(),
      asset: getNextAccount(),
      masterState: getNextAccount(),
      collection: getNextAccount(),
      authority: getNextOptionalAccount(),
      owner: getNextOptionalAccount(),
      updateAuthority: getNextOptionalAccount(),
      systemProgram: getNextAccount(),
      logWrapper: getNextOptionalAccount(),
      mplCore: getNextAccount(),
    },
    data: getMintAssetInstructionDataDecoder().decode(instruction.data),
  };
}
