/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/web3.js';
import { LOCKED_SOL_PNFT_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const MINT_ASSET_DISCRIMINATOR = new Uint8Array([
  84, 175, 211, 156, 56, 250, 104, 118,
]);

export function getMintAssetDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(MINT_ASSET_DISCRIMINATOR);
}

export type MintAssetInstruction<
  TProgram extends string = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountVault extends string | IAccountMeta<string> = string,
  TAccountAsset extends string | IAccountMeta<string> = string,
  TAccountMasterState extends string | IAccountMeta<string> = string,
  TAccountCollection extends string | IAccountMeta<string> = string,
  TAccountMintAuthority extends string | IAccountMeta<string> = string,
  TAccountOwner extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountLogWrapper extends string | IAccountMeta<string> = string,
  TAccountMplCore extends
    | string
    | IAccountMeta<string> = 'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountAsset extends string
        ? WritableSignerAccount<TAccountAsset> &
            IAccountSignerMeta<TAccountAsset>
        : TAccountAsset,
      TAccountMasterState extends string
        ? WritableAccount<TAccountMasterState>
        : TAccountMasterState,
      TAccountCollection extends string
        ? WritableAccount<TAccountCollection>
        : TAccountCollection,
      TAccountMintAuthority extends string
        ? ReadonlyAccount<TAccountMintAuthority>
        : TAccountMintAuthority,
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountLogWrapper extends string
        ? ReadonlyAccount<TAccountLogWrapper>
        : TAccountLogWrapper,
      TAccountMplCore extends string
        ? ReadonlyAccount<TAccountMplCore>
        : TAccountMplCore,
      ...TRemainingAccounts,
    ]
  >;

export type MintAssetInstructionData = { discriminator: ReadonlyUint8Array };

export type MintAssetInstructionDataArgs = {};

export function getMintAssetInstructionDataEncoder(): Encoder<MintAssetInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: MINT_ASSET_DISCRIMINATOR })
  );
}

export function getMintAssetInstructionDataDecoder(): Decoder<MintAssetInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getMintAssetInstructionDataCodec(): Codec<
  MintAssetInstructionDataArgs,
  MintAssetInstructionData
> {
  return combineCodec(
    getMintAssetInstructionDataEncoder(),
    getMintAssetInstructionDataDecoder()
  );
}

export type MintAssetAsyncInput<
  TAccountPayer extends string = string,
  TAccountVault extends string = string,
  TAccountAsset extends string = string,
  TAccountMasterState extends string = string,
  TAccountCollection extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountOwner extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountLogWrapper extends string = string,
  TAccountMplCore extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  vault?: Address<TAccountVault>;
  /** The new asset being created */
  asset: TransactionSigner<TAccountAsset>;
  masterState?: Address<TAccountMasterState>;
  /** The collection this asset belongs to */
  collection: Address<TAccountCollection>;
  mintAuthority?: Address<TAccountMintAuthority>;
  /** The owner of the new asset */
  owner?: Address<TAccountOwner>;
  systemProgram?: Address<TAccountSystemProgram>;
  logWrapper?: Address<TAccountLogWrapper>;
  mplCore?: Address<TAccountMplCore>;
};

export async function getMintAssetInstructionAsync<
  TAccountPayer extends string,
  TAccountVault extends string,
  TAccountAsset extends string,
  TAccountMasterState extends string,
  TAccountCollection extends string,
  TAccountMintAuthority extends string,
  TAccountOwner extends string,
  TAccountSystemProgram extends string,
  TAccountLogWrapper extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
>(
  input: MintAssetAsyncInput<
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountMintAuthority,
    TAccountOwner,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountMintAuthority,
    TAccountOwner,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? LOCKED_SOL_PNFT_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    asset: { value: input.asset ?? null, isWritable: true },
    masterState: { value: input.masterState ?? null, isWritable: true },
    collection: { value: input.collection ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.vault.value) {
    accounts.vault.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([118, 97, 117, 108, 116])),
        getAddressEncoder().encode(expectAddress(accounts.asset.value)),
      ],
    });
  }
  if (!accounts.masterState.value) {
    accounts.masterState.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(new Uint8Array([109, 97, 115, 116, 101, 114])),
        getAddressEncoder().encode(expectAddress(accounts.collection.value)),
      ],
    });
  }
  if (!accounts.mintAuthority.value) {
    accounts.mintAuthority.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            109, 105, 110, 116, 95, 97, 117, 116, 104, 111, 114, 105, 116, 121,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.collection.value)),
      ],
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.asset),
      getAccountMeta(accounts.masterState),
      getAccountMeta(accounts.collection),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.logWrapper),
      getAccountMeta(accounts.mplCore),
    ],
    programAddress,
    data: getMintAssetInstructionDataEncoder().encode({}),
  } as MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountMintAuthority,
    TAccountOwner,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >;

  return instruction;
}

export type MintAssetInput<
  TAccountPayer extends string = string,
  TAccountVault extends string = string,
  TAccountAsset extends string = string,
  TAccountMasterState extends string = string,
  TAccountCollection extends string = string,
  TAccountMintAuthority extends string = string,
  TAccountOwner extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountLogWrapper extends string = string,
  TAccountMplCore extends string = string,
> = {
  payer: TransactionSigner<TAccountPayer>;
  vault: Address<TAccountVault>;
  /** The new asset being created */
  asset: TransactionSigner<TAccountAsset>;
  masterState: Address<TAccountMasterState>;
  /** The collection this asset belongs to */
  collection: Address<TAccountCollection>;
  mintAuthority: Address<TAccountMintAuthority>;
  /** The owner of the new asset */
  owner?: Address<TAccountOwner>;
  systemProgram?: Address<TAccountSystemProgram>;
  logWrapper?: Address<TAccountLogWrapper>;
  mplCore?: Address<TAccountMplCore>;
};

export function getMintAssetInstruction<
  TAccountPayer extends string,
  TAccountVault extends string,
  TAccountAsset extends string,
  TAccountMasterState extends string,
  TAccountCollection extends string,
  TAccountMintAuthority extends string,
  TAccountOwner extends string,
  TAccountSystemProgram extends string,
  TAccountLogWrapper extends string,
  TAccountMplCore extends string,
  TProgramAddress extends Address = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
>(
  input: MintAssetInput<
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountMintAuthority,
    TAccountOwner,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >,
  config?: { programAddress?: TProgramAddress }
): MintAssetInstruction<
  TProgramAddress,
  TAccountPayer,
  TAccountVault,
  TAccountAsset,
  TAccountMasterState,
  TAccountCollection,
  TAccountMintAuthority,
  TAccountOwner,
  TAccountSystemProgram,
  TAccountLogWrapper,
  TAccountMplCore
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? LOCKED_SOL_PNFT_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    asset: { value: input.asset ?? null, isWritable: true },
    masterState: { value: input.masterState ?? null, isWritable: true },
    collection: { value: input.collection ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    mplCore: { value: input.mplCore ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.mplCore.value) {
    accounts.mplCore.value =
      'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d' as Address<'CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.asset),
      getAccountMeta(accounts.masterState),
      getAccountMeta(accounts.collection),
      getAccountMeta(accounts.mintAuthority),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.logWrapper),
      getAccountMeta(accounts.mplCore),
    ],
    programAddress,
    data: getMintAssetInstructionDataEncoder().encode({}),
  } as MintAssetInstruction<
    TProgramAddress,
    TAccountPayer,
    TAccountVault,
    TAccountAsset,
    TAccountMasterState,
    TAccountCollection,
    TAccountMintAuthority,
    TAccountOwner,
    TAccountSystemProgram,
    TAccountLogWrapper,
    TAccountMplCore
  >;

  return instruction;
}

export type ParsedMintAssetInstruction<
  TProgram extends string = typeof LOCKED_SOL_PNFT_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    payer: TAccountMetas[0];
    vault: TAccountMetas[1];
    /** The new asset being created */
    asset: TAccountMetas[2];
    masterState: TAccountMetas[3];
    /** The collection this asset belongs to */
    collection: TAccountMetas[4];
    mintAuthority: TAccountMetas[5];
    /** The owner of the new asset */
    owner?: TAccountMetas[6] | undefined;
    systemProgram: TAccountMetas[7];
    logWrapper?: TAccountMetas[8] | undefined;
    mplCore: TAccountMetas[9];
  };
  data: MintAssetInstructionData;
};

export function parseMintAssetInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedMintAssetInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === LOCKED_SOL_PNFT_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      vault: getNextAccount(),
      asset: getNextAccount(),
      masterState: getNextAccount(),
      collection: getNextAccount(),
      mintAuthority: getNextAccount(),
      owner: getNextOptionalAccount(),
      systemProgram: getNextAccount(),
      logWrapper: getNextOptionalAccount(),
      mplCore: getNextAccount(),
    },
    data: getMintAssetInstructionDataDecoder().decode(instruction.data),
  };
}
